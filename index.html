<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<title>New Game</title>
		<script src="pixi/pixi.min.js"></script>
		<style>
			body
			{
				margin: 0;
				padding: 0;
			}
			
			canvas
			{
				width: 100%;
				height: auto;
			}
		</style>
	</head>
	<body>
		<script>

			//Aliases
			let Application = PIXI.Application,
				Container = PIXI.Container,
				loader = PIXI.loader,
				resources = PIXI.loader.resources,
				Graphics = PIXI.Graphics,
				TextureCache = PIXI.utils.TextureCache,
				Sprite = PIXI.Sprite,
				Text = PIXI.Text,
				TextStyle = PIXI.TextStyle,
				poly = new PIXI.Polygon(new PIXI.Point(0, 0), new PIXI.Point(1200, 600), new PIXI.Point(600, 900)),
				playerPos = new PIXI.Point(0,0),
				mousePos = new PIXI.Point(0,0),
				moveInt = 0,
				moveTime = 0
				moveAngle = 0,
				thing = false;
				//points = [new PIXI.point(0, 0), new PIXI.point(1200, 600), new PIXI.point(600, 900)]
				//point = PIXI.point(0, 0);

			//Create a Pixi Application
			let app = new Application(
			{ 
				width: 1650, 
				height: 900,                       
				antialiasing: true, 
				transparent: false, 
				resolution: 1
			}
			);

			//Add the canvas that Pixi automatically created for you to the HTML document
			document.body.appendChild(app.view);

			loader
			  .add("stick.png")
			  .add("brick.jpg")
			  .add("beach.jpg")
			  .load(setup);
			  
			  
			  let character, wall, beach;
			function setup()
			{
				gameScene = new Container();
				app.stage.addChild(gameScene);
				app.renderer.backgroundColor = 0x000000;
				//Make the sprites and add them to the `gameScene`
				//Create an alias for the texture atlas frame ids
				
				beach = new Sprite(resources["beach.jpg"].texture);
				beach.position.set(0, 0);
				beach.width = 1650;
				beach.height = 1000;
				gameScene.addChild(beach);
				
				character = new Sprite(resources["stick.png"].texture);
				
				character.position.set(825, 500);
				character.height = 120;
				character.width = 90;
				gameScene.addChild(character);
				
				wall = new Graphics();
				wall.beginFill(0xCCFF99);
				wall.drawRect(0, 0, 200, 200);
				wall.endFill();
				wall.position.set(1000, 200);
				
				gameScene.addChild(wall);
				
				app.stage.interactive = true;
					
				app.ticker.add(delta => gameLoop(delta));
			}
			
			function gameLoop(delta)
			{	
				app.stage.on("click", function()
				{
					mousePos = new PIXI.Point(app.renderer.plugins.interaction.mouse.global.x, app.renderer.plugins.interaction.mouse.global.y);
					playerPos = new PIXI.Point(character.position.x + 45, character.position.y + 100);
					moveAngle = angle(playerPos.x, playerPos.y, mousePos.x, mousePos.y);
					moveTime = Math.floor(distance(playerPos.x, playerPos.y, mousePos.x, mousePos.y) / 5)
					moveInt = 0;
				});
				
				if (moveInt != moveTime)
				{
					if (hitTestRectangle(character, wall, 5 * Math.sign(mousePos.x - playerPos.x), 5 * Math.sign(mousePos.y - playerPos.y)))
					{
						moveInt = moveTime;
					}
					else
					{
						character.position.x += 5 * Math.cos(moveAngle);
						character.position.y += 5 * Math.sin(moveAngle);
						moveInt++;
					}
				}
			}
			
			function hitTestRectangle(r1, r2, modX, modY)
			{
				//Returns false if the center points of both objects are closer than half 
				//the sum of their widths and heights on the x and y axes (respectively) with a modifier.
					//Modifier added to allow players to move away from obstacles (would normally get stuck).
				
				return ((Math.abs(r1.x - r2.x + (r1.width - r2.width) / 2 + modX) < (r1.width + r2.width) / 2) && (Math.abs(r1.y - r2.y  + (r1.height - r2.height) / 2 + modY) < (r1.height + r2.height) / 2));
			    
				/*ELABORATED VERSION       (if uncommented, should work just as well)
				
			    let combinedHalfWidths, combinedHalfHeights, vx, vy;
			    
			    hit = false;                                 //hit will determine whether there's a collision
				
			    r1.halfW = r1.width / 2;
			    r1.halfH = r1.height / 2;
			    r2.halfW = r2.width / 2;                     //Find the half-widths and half-heights of each sprite
			    r2.halfH = r2.height / 2;
				
			    r1.centerX = r1.x + modX + r1.halfW; 
			    r1.centerY = r1.y + modY + r1.halfH;         //Find the center points of each sprite
			    r2.centerX = r2.x + r2.halfW; 
			    r2.centerY = r2.y + r2.halfH; 
			    
			    vx = r1.centerX - r2.centerX;                //Calculate the distance vector between the sprites
			    vy = r1.centerY - r2.centerY;

			    
			    combinedHalfWidths = r1.halfW + r2.halfW;    //Figure out the combined half-widths and half-heights
			    combinedHalfHeights = r1.halfH + r2.halfH;
			  
				if (Math.abs(vx) < combinedHalfWidths) 
				{
					if (Math.abs(vy) < combinedHalfHeights) 
					{
					  hit = true;                            //x or y colliding
					} 
					else 
					{
					  hit = false;                           //no y collide
					}
				} 
				else 
				{
					hit = false;                             //no x collide
				}

				return hit;*/
			}
			
			
			function distance(xFrom, yFrom, xTo, yTo)
			{
				//Uses Pythagorean Theorem to determine the shortest possible distance between 2 points
				
				return Math.sqrt (Math.pow (xTo - xFrom, 2) + (Math.pow (yTo - yFrom, 2)));
				
				/*ELABORATED VERSION       (if uncommented, should work just as well)
				
				let a, b, c;            //(a squared + b squared = c squared
				
				a = xTo - xFrom;        //set a to the raw x distance
				a = a * a;              //square it
				
				b = yTo - xFrom;        //set it to the raw y distance
				b = b * b;              //square it
				
				c = a + b;              //add a and b
				c = Math.sqrt(c);       //find the square root
				
				return c;*/
			}
			
			function angle(fromX, fromY, toX, toY)
			{
				//Finds the angle between 2 points (returns in degrees)
				
				return Math.acos ((toX - fromX) / distance(fromX, fromY, toX, toY)) * Math.sign(toY - fromY);
				
				/*ELABORATED VERSION       (if uncommented, should work just as well)
				
				let xDist, yDist, hyp, frac, ang;      //cosine is opposite / hypotenuse
				
				xDist = toX - fromX;
				yDist = toY - fromY;                   //find the x and y distances between the points
				
				hyp = distance(fromX, fromY, toX, toY) //uses above function to find the length of the hypotenuse
				
				frac = xDist / hyp;                    //divide the horizonral leg by the hypotenuse to get the ratio between them
				
				ang = Math.acos(frac);                 //find the angle by using the inverse cosine trig function on the leg-to-hypotnuse ratio
				
				ang = ang * Math.sign(yDist);          //set the angle to positive or negative based on whether this is pointing up or down
				
				
				return ang;*/
			}
			
			function keyboard(keyCode) 
			{
				let key = {};               //creates an empty object called "key"
				key.code = keyCode;         //
				key.isDown = false;         //
				key.isUp = true;
				key.press = undefined;
				key.release = undefined;

				//The `downHandler`
				key.downHandler = function(event) 
				{
					if (event.keyCode === key.code) 
					{
					    if (key.isUp && key.press) key.press();
					    key.isDown = true;
					    key.isUp = false;
					}
					event.preventDefault();
				};

				  //The `upHandler`
				key.upHandler = function(event) 
				{
					if (event.keyCode === key.code) 
					{
					    if (key.isDown && key.release) key.release();
					    key.isDown = false;
					    key.isUp = true;
					}
					event.preventDefault();
				};

				  //Attach event listeners
				window.addEventListener(
					"keydown", key.downHandler.bind(key), false
				);
				window.addEventListener(
					"keyup", key.upHandler.bind(key), false
				);
				return key;
			}
		</script>
	</body>  
</html>
  
  
  
  
  
  
  
  
  
  
  
