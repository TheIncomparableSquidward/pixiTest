<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<title>New Game</title>
		<script src="pixi/pixi.min.js"></script>
		<style>
			body
			{
				margin: 0;
				padding: 0;
			}
			
			canvas
			{
				width: 100%;
				height: auto;
			}
		</style>
	</head>
	<body>
		<script>

			//Aliases
			let Application = PIXI.Application,
				Container = PIXI.Container,
				loader = PIXI.loader,
				resources = PIXI.loader.resources,
				Graphics = PIXI.Graphics,
				TextureCache = PIXI.utils.TextureCache,
				Sprite = PIXI.Sprite,
				Text = PIXI.Text,
				TextStyle = PIXI.TextStyle,
				poly = new PIXI.Polygon(new PIXI.Point(0, 0), new PIXI.Point(1200, 600), new PIXI.Point(600, 900)),
				playerPos = new PIXI.Point(0,0),
				mousePos = new PIXI.Point(0,0),
				moveInt = 0,
				moveTime = 0
				moveAngle = 0,
				thing = false;
				//points = [new PIXI.point(0, 0), new PIXI.point(1200, 600), new PIXI.point(600, 900)]
				//point = PIXI.point(0, 0);

			//Create a Pixi Application
			let app = new Application(
			{ 
				width: 1650, 
				height: 900,                       
				antialiasing: true, 
				transparent: false, 
				resolution: 1
			}
			);

			//Add the canvas that Pixi automatically created for you to the HTML document
			document.body.appendChild(app.view);

			loader
			  .add("stick.png")
			  .add("brick.jpg")
			  .add("beach.jpg")
			  .load(setup);
			  
			  
			  let character, bricks, beach;
			function setup()
			{
				gameScene = new Container();
				app.stage.addChild(gameScene);
				app.renderer.backgroundColor = 0x000000;
				//Make the sprites and add them to the `gameScene`
				//Create an alias for the texture atlas frame ids
				
				beach = new Sprite(resources["beach.jpg"].texture);
				beach.position.set(0, 0);
				beach.width = 1650;
				beach.height = 1000;
				gameScene.addChild(beach);
				
				character = new Sprite(resources["stick.png"].texture);
				character.x = 60;
				character.y = 50;
				character.height = 400;
				character.width = 300;
				gameScene.addChild(character);
				
				/*bricks = new Sprite(resources["brick.jpg"].texture); 
				bricks.position.set(200, 200);
				gameScene.addChild(bricks);*/
				
				app.stage.interactive = true;
					
				app.ticker.add(delta => gameLoop(delta));
				}
			
			function gameLoop(delta)
			{
				//Move the cat 1 pixel 
				/*character.x += 3;
				
				if (character.x > screen.width)
				{
					character.x = -200;
				}*/
				
				//character.position.set(app.renderer.plugins.interaction.mouse.global.x, app.renderer.plugins.interaction.mouse.global.y);
				
				
				app.stage.on("click", function()
				{
					mousePos = new PIXI.Point(app.renderer.plugins.interaction.mouse.global.x, app.renderer.plugins.interaction.mouse.global.y);
					playerPos = new PIXI.Point(character.position.x + 150, character.position.y + 370);
					moveAngle = angle(playerPos.x, playerPos.y, mousePos.x, mousePos.y);
					moveTime = Math.floor(distance(playerPos.x, playerPos.y, mousePos.x, mousePos.y) / 5)
					moveInt = 0;
				});
				
				if (moveInt != moveTime)
				{
					character.position.x += 5 * Math.cos(moveAngle);
					character.position.y += 5 * Math.sin(moveAngle);
					moveInt++;
				}
				
				//console.log(Math.sin(30/57.2958));
				
				/*if (character.position.x != mousePos.x || character.position.y != mousePos.y)
				{
					
				}*/
				//90, 420
				//console.log(character.position);
			}
			
			function slide()
			{
				let tmp = 0;
				
				
				while (tmp < 60)
				{
					character.position.x += (mousePos.x - playerPos.x) / 60;
					character.position.y += (mousePos.y - playerPos.y) / 60;
					tmp ++;
				}
				/*if (tmp <= 20)
				{
					character.position.x += (mousePos.x - playerPos.x) / 20;
					character.position.y += (mousePos.y - playerPos.y) / 20;
					tmp += 1;
				}
				else
				{
					app.ticker.stop(slide(delta));
				}
				
				console.log(tmp);*/
				
			}
			
			function distance(xFrom, yFrom, xTo, yTo)
			{
				return Math.sqrt (Math.pow (xTo - xFrom, 2) + (Math.pow (yTo - yFrom, 2)));
			}
			
			function angle(fromX, fromY, toX, toY)
			{
				return Math.acos ((toX - fromX) / distance(fromX, fromY, toX, toY)) * Math.sign(toY - fromY);
			}
			
			function keyboard(keyCode) 
			{
				let key = {};
				key.code = keyCode;
				key.isDown = false;
				key.isUp = true;
				key.press = undefined;
				key.release = undefined;

				//The `downHandler`
				key.downHandler = function(event) 
				{
					if (event.keyCode === key.code) 
					{
					    if (key.isUp && key.press) key.press();
					    key.isDown = true;
					    key.isUp = false;
					}
					event.preventDefault();
				};

				  //The `upHandler`
				key.upHandler = function(event) 
				{
					if (event.keyCode === key.code) 
					{
					    if (key.isDown && key.release) key.release();
					    key.isDown = false;
					    key.isUp = true;
					}
					event.preventDefault();
				};

				  //Attach event listeners
				window.addEventListener(
					"keydown", key.downHandler.bind(key), false
				);
				window.addEventListener(
					"keyup", key.upHandler.bind(key), false
				);
				return key;
			}
		</script>
	</body>  
</html>
  
  
  
  
  
  
  
  
  
  
  
