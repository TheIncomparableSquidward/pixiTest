<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<title>New Game</title>
		<script src="pixi/pixi.min.js"></script>
		<style>
			body
			{
				margin: 0;
				padding: 0;
			}
			
			canvas
			{
				width: 100%;
				height: auto;
			}
		</style>
	</head>
	<body>
		<script>

			//Aliases
			let Application = PIXI.Application,
				Container = PIXI.Container,
				loader = PIXI.loader,
				resources = PIXI.loader.resources,
				Graphics = PIXI.Graphics,
				TextureCache = PIXI.utils.TextureCache,
				Sprite = PIXI.Sprite,
				Text = PIXI.Text,
				TextStyle = PIXI.TextStyle,
				poly = new PIXI.Polygon(new PIXI.Point(0, 0), new PIXI.Point(1200, 600), new PIXI.Point(600, 900)),
				playerPos = new PIXI.Point(0,0),
				mousePos = new PIXI.Point(0,0),
				moveInt = 0,
				moveTime = 0
				moveAngle = 0,
				thing = false;
				//points = [new PIXI.point(0, 0), new PIXI.point(1200, 600), new PIXI.point(600, 900)]
				//point = PIXI.point(0, 0);

			//Create a Pixi Application
			let app = new Application(
			{ 
				width: 1650, 
				height: 900,                       
				antialiasing: true, 
				transparent: false, 
				resolution: 1
			}
			);

			//Add the canvas that Pixi automatically created for you to the HTML document
			document.body.appendChild(app.view);

			loader
			  .add("stick.png")
			  .add("brick.jpg")
			  .add("beach.jpg")
			  .load(setup);
			  
			  
			  let character, wall, beach;
			function setup()
			{
				gameScene = new Container();
				app.stage.addChild(gameScene);
				app.renderer.backgroundColor = 0x000000;
				//Make the sprites and add them to the `gameScene`
				//Create an alias for the texture atlas frame ids
				
				beach = new Sprite(resources["beach.jpg"].texture);
				beach.position.set(0, 0);
				beach.width = 1650;
				beach.height = 1000;
				gameScene.addChild(beach);
				
				character = new Sprite(resources["stick.png"].texture);
				
				character.position.set(60, 50);
				character.height = 120;
				character.width = 90;
				gameScene.addChild(character);
				
				wall = new Graphics();
				wall.beginFill(0xCCFF99);
				wall.drawRect(0, 0, 200, 200);
				wall.endFill();
				wall.position.set(1000, 200);
				
				gameScene.addChild(wall);
				
				app.stage.interactive = true;
					
				app.ticker.add(delta => gameLoop(delta));
			}
			
			function gameLoop(delta)
			{
				//Move the cat 1 pixel 
				/*character.x += 3;
				
				if (character.x > screen.width)
				{
					character.x = -200;
				}*/
				
				//character.position.set(app.renderer.plugins.interaction.mouse.global.x, app.renderer.plugins.interaction.mouse.global.y);
				
				
				app.stage.on("click", function()
				{
					mousePos = new PIXI.Point(app.renderer.plugins.interaction.mouse.global.x, app.renderer.plugins.interaction.mouse.global.y);
					playerPos = new PIXI.Point(character.position.x + 45, character.position.y + 100);
					moveAngle = angle(playerPos.x, playerPos.y, mousePos.x, mousePos.y);
					moveTime = Math.floor(distance(playerPos.x, playerPos.y, mousePos.x, mousePos.y) / 5)
					moveInt = 0;
				});
				
				if (moveInt != moveTime)
				{
				
					
					
					if (hitTestRectangle(character, wall, 5 * Math.sign(mousePos.x - playerPos.x), 5 * Math.sign(mousePos.y - playerPos.y)))
					{
						moveInt = moveTime;
					}
					else
					{
						character.position.x += 5 * Math.cos(moveAngle);
						character.position.y += 5 * Math.sin(moveAngle);
						moveInt++;
					}
				}
				
				//console.log(Math.sin(30/57.2958));
				
				/*if (character.position.x != mousePos.x || character.position.y != mousePos.y)
				{
					
				}*/
				//90, 420
				//console.log(character.position);
			}
			
			function hitTestRectangle(r1, r2, modX, modY)
			{

			    //Define the variables we'll need to calculate
			    let combinedHalfWidths, combinedHalfHeights, vx, vy;

			    //hit will determine whether there's a collision
			    //hit = false;
				
				//Find the half-widths and half-heights of each sprite
			    r1.halfW = r1.width / 2;
			    r1.halfH = r1.height / 2;
			    r2.halfW = r2.width / 2;
			    r2.halfH = r2.height / 2;
				
			    //Find the center points of each sprite
			    r1.centerX = r1.x + modX + r1.halfW; 
			    r1.centerY = r1.y + modY + r1.halfH; 
			    r2.centerX = r2.x + r2.halfW; 
			    r2.centerY = r2.y + r2.halfH; 
 
			    

			    //Calculate the distance vector between the sprites
			    vx = r1.centerX - r2.centerX;
			    vy = r1.centerY - r2.centerY;

			    //Figure out the combined half-widths and half-heights
			    combinedHalfWidths = r1.halfW + r2.halfW;
			    combinedHalfHeights = r1.halfH + r2.halfH;

			  /*Check for a collision on the x axis
				if (Math.abs(vx) < combinedHalfWidths) 
				{
					//A collision might be occuring. Check for a collision on the y axis
					if (Math.abs(vy) < combinedHalfHeights) 
					{
					  //There's definitely a collision happening
					  hit = true;
					} 
					else 
					{
					  //There's no collision on the y axis
					  hit = false;
					}
				} 
				else 
				{

					//There's no collision on the x axis
					hit = false;
				}

				  //`hit` will be either `true` or `false`
				return hit;*/
				return ((Math.abs(vx) < combinedHalfWidths) && (Math.abs(vy) < combinedHalfHeights));
			};
			
			function slide()
			{
				let tmp = 0;
				
				
				while (tmp < 60)
				{
					character.position.x += (mousePos.x - playerPos.x) / 60;
					character.position.y += (mousePos.y - playerPos.y) / 60;
					tmp ++;
				}
				/*if (tmp <= 20)
				{
					character.position.x += (mousePos.x - playerPos.x) / 20;
					character.position.y += (mousePos.y - playerPos.y) / 20;
					tmp += 1;
				}
				else
				{
					app.ticker.stop(slide(delta));
				}
				
				console.log(tmp);*/
				
			}
			
			function distance(xFrom, yFrom, xTo, yTo)
			{
				return Math.sqrt (Math.pow (xTo - xFrom, 2) + (Math.pow (yTo - yFrom, 2)));
			}
			
			function angle(fromX, fromY, toX, toY)
			{
				return Math.acos ((toX - fromX) / distance(fromX, fromY, toX, toY)) * Math.sign(toY - fromY);
			}
			
			function keyboard(keyCode) 
			{
				let key = {};
				key.code = keyCode;
				key.isDown = false;
				key.isUp = true;
				key.press = undefined;
				key.release = undefined;

				//The `downHandler`
				key.downHandler = function(event) 
				{
					if (event.keyCode === key.code) 
					{
					    if (key.isUp && key.press) key.press();
					    key.isDown = true;
					    key.isUp = false;
					}
					event.preventDefault();
				};

				  //The `upHandler`
				key.upHandler = function(event) 
				{
					if (event.keyCode === key.code) 
					{
					    if (key.isDown && key.release) key.release();
					    key.isDown = false;
					    key.isUp = true;
					}
					event.preventDefault();
				};

				  //Attach event listeners
				window.addEventListener(
					"keydown", key.downHandler.bind(key), false
				);
				window.addEventListener(
					"keyup", key.upHandler.bind(key), false
				);
				return key;
			}
		</script>
	</body>  
</html>
  
  
  
  
  
  
  
  
  
  
  
